man(){
    #set -x
    #hit=1
    #setopt extendedglob
    if [[ -z $2 ]] && ! /bin/ls $HOME/helpers/man/**/$1.* &>/dev/null;then
    #hit=0
    location=`/usr/bin/man -M /usr/share/man -w $1`
    number=${${location:t}[(ws:.:)2]}
    gunzip -c $location  >| $HOME/helpers/man/man${number//[a-z]/}/$1.${number}
    fi
    LC_ALL=C LANG=C TERMINFO=~/.terminfo/ TERM=mostlike /usr/bin/man $1
    #echo $MANPATH
    #echo $hit
    #set +x
}

append(){
    echo "Enter stuff"
    cat >>$1
}

function {reboot,sdown} {
    echo "Sure y/N"
    read -q && $0
}

cd () {

    emulate -LR zsh

    if [[ $# -ge 3 ]]; then
        echo cd: too many arguments >&2
        return 1
    elif [[ $# -eq 2 ]]; then
        ## builtin cd $1 $2
        local newdir=${(S)PWD//$1/$2}
        echo $newdir
        builtin cd $newdir
    elif [[ $# -eq 1 ]]; then
        if [[ ! -d $1 && -d $1:h ]]; then
            echo $1:h
            builtin cd $1:h
        else
            builtin cd $1
        fi
    else
        builtin cd
        fi
}



weechat(){
    weechat-curses 2>/dev/null
}

tmpwrite(){
  $file = mktemp
  /usr/bin/vim $file
  mv $file $file.d
}

apod(){
    #set -x
    DATE=`date +%s`
    FILE="$HOME/.cache/apod/apod:$DATE.jpg"
    apodTemp=$(mktemp)
    curl -s http://apod.nasa.gov/apod/ >| $apodTemp
    apodDesc=$(perl -lne 'print $_ if /Explanation:/../Tomorrow/' $apodTemp | w3m -dump -T text/html | head -n -1)
    url="$(grep IMG $apodTemp | cut -d "\"" -f 2)"
    wget -q -O "$FILE" -c http://apod.nasa.gov/apod/${=url}
    exiftool -overwrite_original -UserComment="$apodDesc" $FILE
    feh $FILE &
    echo $apodDesc | par f | xmessage -file - -timeout 30
    echo "Set as wallpaper: y/n"
    read -q  && set_wall $FILE
    #set +x
}

server(){
if [[ $1 == start ]];then
    python -m SimpleHTTPServer 9914 &>~/logs/server.log &
else
    $TBROWSER http://localhost:9914/
fi
}


isurl(){
    url="$@"
    # Using a much simpler version -- skt
    curl -I -s "$url" &>/dev/null || return 1
    return 0
    #zmodload zsh/regex
    #[[ $url -regex-match "^http://.+\..{2,3}$" || $url -regex-match ".+\..{2,3}$" || $url -regex-match ".+\..+/.+" ]] \
        #&& [[ ! $url == /*   ]] \
        #&& [[ ! $url == ./* ]] \
        #&& return 0
    #return 1
}

mecho(){
    #detect if being invoked through dmenu or terminal - use zenity or stdout
    #based on that
    if [[ -t 1 ]];then
        output="cat"
    else
        output="zenity --text-info --height 400 --width 680"
    fi
    echo "$@" | ${=output}
}

spath(){
    for dir in $(tr ':' '\n' <<< $PATH);do
        find $dir -maxdepth 1 -type f | /bin/grep -i --color ".*lock.*"
    done
}

task()
{
if [[ -z $1 || $1 == "add" ]];then
    echo "Name"
    read name
    file="$HOME/.tasks/${name// /-}"
    #touch $file
    echo "Description:"
    read desc
    echo "$desc" >! "${=file}.remain"
else
    echo "Task list"
    counter=1
    for i in $(ls -A ~/.tasks/*.remain);do
        echo -e "\n\nTask #$counter: ${=i}"
        echo "Description:"
        cat "${=i}"
        echo -e "\n\n"
        echo "Is this task done?(y/N)"
        read -q && mv ${=i} ${=i:r}.done
        counter=$(($counter+1))
    done
fi

}

comcache(){
export PATH="/usr/lib/ccache/bin/:$PATH"
}

ad2que(){
trap 'break' INT
local tset
local input
while :;do
    read $input
    if ! which =$input[(w)1] &>/dev/null;then
        input="shellrun $input"
    fi
    tset="$tset
    $input"
done
echo "$tset" >> ~/.dque
}


xpaste(){
    file="$1"
    [[ -z $file ]] &&  file="$HOME/note"
    var="$(xsel -o)"
    echo -e "$var" >> $file
    notify-send "Added note" "$var"
}

wiki() { w=$(dig +short txt $1.wp.dg.cx); echo "$w" }

less_vim() {
    =vim -R \
    -c 'let no_plugin_maps = 1' \
    -c 'set scrolloff=5' \
    -c 'runtime! macros/less.vim' \
    -c 'set foldlevel=999' \
    -c 'set mouse=h' \
    -c 'set nonu' \
    -c 'nmap <ESC>u :nohlsearch<cr>' \
    "$@"
}


dfilter(){
    # Should return array
    dchoice=$( eval $@ | awk '{ print NR,$0 }' | ${=DMENU} | awk '{ print $2 }')
    echo "$dchoice"

}

mangrep(){
    /usr/bin/man "$1" | grep -5 "$2"
}


help(){  run-help "$@" || less_vim -c ":/$@/" ~/.zshguide.txt }

disassemble() {
        emulate -L zsh
            gcc -pipe -S -o - -O -g $* | as -aldh -o /dev/null
        }

profile() {
        ZSH_PROFILE_RC=1 $SHELL "$@"
}


xev(){
    =xev -id `xdotool getactivewindow`
}

bash_source() {
  alias shopt=':'
  alias _expand=_bash_expand
  alias _complete=_bash_comp
  #emulate -L sh
  setopt kshglob noshglob braceexpand
  source "$@"
}

rsudo(){
echo "$@" | sudo tee
}

search(){
    surfraw google "$@"
}

#$firefox(){
#$LD_PRELOAD=/usr/lib/libtcmalloc_minimal.so /usr/bin/firefox
#}

ins(){
   if [[ $1 == *xz || $1 == *pkg.tar ]];then
      sudo pacman -U $1
   else
     sudo pacman -S "$@"
 fi
}

_force_rehash()
{
    (( CURRENT == 1 )) && rehash
    return 1
}

extract() {
   if [[ -z "$1" ]] ; then
       print -P "usage: \e[1;36mextract\e[1;0m < filename >"
       print -P "       Extract the file specified based on the extension"
   elif [[ -f $1 ]] ; then
       case ${(L)1} in
           *.tar.bz2)  tar -jxvf $1    ;;
           *.tar.xz|*.xz)   tar -xvf $1    ;;
           *.tar.gz)   tar -zxvf $1    ;;
           *.bz2)      bunzip2 $1       ;;
           *.gz)       gunzip $1       ;;
           *.jar)      unzip $1       ;;
           *.rar)      unrar x $1       ;;
           *.tar)      tar -xvf $1       ;;
           *.tbz2)     tar -jxvf $1    ;;
           *.tgz)      tar -zxvf $1    ;;
           *.zip)      unzip $1          ;;
           *.Z)        uncompress $1    ;;
           *)          echo "Unable to extract '$1' :: Unknown extension"
       esac
   else
       echo "File ('$1') does not exist!"
   fi

}

pacnews()
{
    for n in /etc/**/*.pacnew; do 
        if [[ -r ${n%.*} ]]; then 
            sudo vimdiff $n ${n%.*} &&
            echo "Replace?"; read -q && sudo mv $n ${n%.*}
        fi 
    done
}

dlink(){
    curl -s "$@" | w3m -dump -T text/html
}

H-Glob() {
    echo -e "
    /      directories
    .      plain files
    @      symbolic links
    =      sockets
    p      named pipes (FIFOs)
    *      executable plain files (0100)
    %      device files (character or block special)
    %b     block special files
    %c     character special files
    r      owner-readable files (0400)
    w      owner-writable files (0200)
    x      owner-executable files (0100)
    A      group-readable files (0040)
    I      group-writable files (0020)
    E      group-executable files (0010)
    R      world-readable files (0004)
    W      world-writable files (0002)
    X      world-executable files (0001)
    s      setuid files (04000)
    S      setgid files (02000)
    t      files with the sticky bit (01000)

  print *(m-1)          # Files modified up to a day ago
  print *(a1)           # Files accessed a day ago
  print *(@)            # Just symlinks
  print *(Lk+50)        # Files bigger than 50 kilobytes
  print *(Lk-50)        # Files smaller than 50 kilobytes
  print **/*.c          # All *.c files recursively starting in \$PWD
  print **/*.c~file.c   # Same as above, but excluding 'file.c'
  print (foo|bar).*     # Files starting with 'foo' or 'bar'
  print *~*.*           # All Files that do not contain a dot
  chmod 644 *(.^x)      # make all plain non-executable files publically readable
  print -l *(.c|.h)     # Lists *.c and *.h
  print **/*(g:users:)  # Recursively match all files that are owned by group 'users'
  echo /proc/*/cwd(:h:t:s/self//) # Analogous to >ps ax | awk '{print $1}'<"
}
#alias help-zshglob=H-Glob

